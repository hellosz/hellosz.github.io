---
title: Introduction
tags: technical algorithm
category: technical
key: a251a54fbe67e519c7c10c4a73a27f4c
comment: true
---



重新梳理算法分析的**基础理论知识**，包括`算法的分析思路`、`Big O近似分析法`和`主项式定理`的使用等。

<!--more-->

## 一、算法的解题思路

1. 沟通交流，明确题目具体要求
2. 给处合理的问题解决算法
3. 分析时间、空间复杂度
4. 算法实现
5. 给出测试用例

## 二、算法分析

![时间算法复杂度](/assets/images/algorithmmatters.png)

算法分析是为了确认代码的运行时间，会随着输入的大小如何变化；其中通常会重点关注`最好的情况`、`最坏的情况`和`平均情况`，由于`平均情况`很难测定，**所以**通常关注`最差的情况`

## 三、近似记法

### **Big O**分析法：

`T(n) = O(f(n))`表示存在一个常数C，使得当n趋近于无穷大时总有T(n) <= C * f(n)，即当n趋近于无穷大时的上界是C * f(n)，记作`T(n) = O(f(n))`，即`O(f(n))`为算法的**时间复杂度**。

## 四、P、NP问题

### Polynomial - 多项式问题

`O(log2 N)`、`O(n)`、`O(nlog2 N)`、`O(n^2)`和`O(n^3)`

当前，在处理实际应用问题时，只讨论P问题



### Non-Deterministic Polynomial - 非确定多项式问题

`O(2^n)`、`O(n!)`



## 五、主项定理的应用

设`a>=1，b>1`为常数，设`f(n)`为一函数（表示执行时间），`T(n)`为递归式构成：

> T(n) = a(T(n/b)) + f(n)

其中，那么`T(n)`就有三种可能：

- n ^ (loga b) > f(n)，则时间复杂对为n ^ (loga b)
- n ^ (loga b) = f(n)，则时间复杂度为f(n) * logn
- n ^ (loga b) < f(n)，则时间复杂度为f(n)

其中，a表示分治后需要处理的项数，b表示问题被分治的规模。

